// Basic program structure
Program: /\s*/ lines*=SourceLine[/\n\s*/] /\s*/;
SourceLine: (line_number=INT)? (label=Label ':')? statements*=Statement[':'];

// =====================================
// Syntactic Class Patterns
// =====================================

// CLASS_00: No operands
// Usage: Just the keyword alone
// Example: NEW, STOP, RETURN
// Pattern: /\bKEYWORD\b/

// CLASS_01: Variable
// Usage: Requires a variable name
// Example: Used in LET
// Rule needed for runtime single-letter check

// CLASS_02: Expression
// Usage: Requires any expression
// Example: Right side of LET

// CLASS_03: Optional numeric expression
// Usage: Optional expression that must be numeric at runtime
// Example: RUN [expr]
// Pattern: (expression=Expression)?

// CLASS_04: Single-character variable
// Usage: Single letter variable name
// Example: FOR/NEXT control variables
// Uses Variable rule but with runtime check for single letter

// CLASS_05: List of items
// Usage: Set of items separated by delimiters
// Example: PRINT items
// Rule needed for complex cases like PRINT

// CLASS_06: Required numeric expression
// Usage: Expression that must be numeric at runtime
// Example: GOTO expr
// Pattern: expression=Expression

// CLASS_07: Colour items
// Usage: Colour parameters
// Example: INK, PAPER

// CLASS_08: Two numeric expressions with comma
// Usage: Two expressions that must be numeric at runtime
// Example: POKE addr, value
// Pattern: expr1=Expression ',' expr2=Expression

// CLASS_09: CLASS_08 with optional colour items
// Usage: Like CLASS_08 but with optional colour parameters
// Example: PLOT
// Pattern: (colour=ColourParam)* expr1=Expression ',' expr2=Expression

// CLASS_0A: String expression
// Usage: Expression that must be string at runtime
// Example: SAVE with filename
// Pattern: expression=Expression

// CLASS_0B: Cassette operations
// Usage: Complex patterns for tape operations
// Example: SAVE, LOAD, VERIFY
// Will need specific rules for each variant

// Expressions

// Expression grammar for ZX Spectrum BASIC

// Top level expression handles OR (lowest precedence)
Expression: OrExpr;

// Precedence levels from low (2) to high (10)
OrExpr: first=AndExpr rest*=OrOpExpr;
OrOpExpr: op=/\bOR\b/ expr=AndExpr;

AndExpr: first=CompareExpr rest*=AndOpExpr;
AndOpExpr: op=/\bAND\b/ expr=CompareExpr;

// All comparison operators have same precedence (5)
CompareExpr: first=AddExpr rest*=CompareOpExpr;
CompareOpExpr: op=CompareOp expr=AddExpr;
CompareOp: '<=' | '>=' | '<>' | '>' | '<' | '=';

// Addition/subtraction (priority 6)
// AddExpr: exprs=MultExpr (('+' | '-') MultExpr)*;
AddExpr: first=MultExpr rest*=AddOpExpr;
AddOpExpr: op=AddOp expr=MultExpr;
AddOp: '+' | '-';

// Multiplication/division (priority 8)
// MultExpr: PowerExpr (('*' | '/') PowerExpr)*;
MultExpr: first=PowerExpr rest*=MultOpExpr;
MultOpExpr: op=MultOp expr=PowerExpr;
MultOp: '*' | '/';

// Power operator (priority 10)
// PowerExpr: FunctionExpr ('^' FunctionExpr)*;
PowerExpr: first=FunctionExpr rest*=PowerOpExpr;
PowerOpExpr: op='^' expr=FunctionExpr;

// Functions and primary expressions
FunctionExpr: Function | SpecialFn | Primary;

// Functions (parentheses optional unless needed for precedence)
Function: name=FunctionName (expr=FunctionExpr | '(' expr=Expression ')');
FunctionName: /\bABS\b/ | /\bACS\b/ | /\bASN\b/ | /\bATN\b/ | /\bCOS\b/ | /\bEXP\b/ | /\bINT\b/ | 
             /\bLN\b/ | /\bSGN\b/ | /\bSIN\b/ | /\bSQR\b/ | /\bTAN\b/ | /\bUSR\b/ | /\bLEN\b/ |
             /\bCODE\b/ | /\bVAL\b/ | 'CHR$' | 'STR$' | 'VAL$' | /\bNOT\b/ | '-';

// Functions with multiple arguments
TwoArgName: /\bATTR\b/ | /\bPOINT\b/ | 'SCREEN$';
TwoArgFn: name=TwoArgName '(' expr1=Expression ',' expr2=Expression ')';
PiValue: /\bPI\b/;
BinValue: /\bBIN\b/ digits=/[01]+/;
Fn: /\bFN\b/ name=VarSymbol '(' args*=Expression[','] ')';
SpecialFn: TwoArgFn | PiValue | BinValue | Fn;

// Primary expressions
Primary: Number | String | Label | VarDest | '(' Expression ')';

Number: value=NUMBER;
String: value=/"(?:[^"\n]|"")*"/;

// Variables and Array references
ArrayRef: name=VarSymbol '(' subscripts+=SliceExpression[','] ')';
Variable: name=VarSymbol;
VarSymbol: /[A-Z][ \tA-Z0-9]*\$?/;
VarDest: ArrayRef | Variable;

Slice: 
    /\bTO\b/ max=Expression |                  // From start: A$(TO 10)
    min=Expression /\bTO\b/ max=Expression |   // Range: A$(2 TO 10)
    min=Expression /\bTO\b/;                   // To end: A$(2 TO)

SliceExpression: Slice | Expression;

// =====================================
// Initial Statement Implementation
// =====================================
Statement: New | Stop | Return | Continue | Copy | Cls | Cat | Goto | Gosub |
    Restore | Pause | Border | Run | Clear | Randomize | Beep | Out |
    Poke | Let | Read | Data | Dim | For | Next | If | ColourStmt | 
    Plot | Draw | Circle | Print | Lprint | Input | Save |
    Load | Verify | Merge | DefFn | Rem;

// Statement types organized by their class patterns

// ==================================
// CLASS_00 - No operands
// ==================================
New: /\bNEW\b/;
Stop: /\bSTOP\b/;
Return: /\bRETURN\b/;
Continue: /\bCONTINUE\b/;
Copy: /\bCOPY\b/;
Cls: /\bCLS\b/;
Cat: /\bCAT\b/;

// ==================================
// Simple CLASS_06 - Single numeric expression
// ==================================
Goto: /\bGOTO\b/ expr=Expression | 'GO TO' expr=Expression;
Gosub: /\bGOSUB\b/ expr=Expression | 'GO SUB' expr=Expression;
Restore: /\bRESTORE\b/ expr=Expression;
Pause: /\bPAUSE\b/ expr=Expression;
Border: /\bBORDER\b/ expr=Expression;

// ==================================
// CLASS_03 - Optional numeric expression
// ==================================
Run: /\bRUN\b/ (expr=Expression)?;
Clear: /\bCLEAR\b/ (expr=Expression)?;
Randomize: /\bRANDOMIZE\b/ (expr=Expression)?;

// ==================================
// CLASS_08 - Two numeric expressions
// ==================================
Beep: /\bBEEP\b/ expr1=Expression ',' expr2=Expression;
Out: /\bOUT\b/ expr1=Expression ',' expr2=Expression;
Poke: /\bPOKE\b/ expr1=Expression ',' expr2=Expression;

// ==================================
// Variable and assignment statements
// ==================================
Let: /\bLET\b/ var=VarDest '=' expr=Expression;
Read: /\bREAD\b/ vars+=VarDest[','];
Data: /\bDATA\b/ items+=Expression[','];
Dim: /\bDIM\b/ name=VarSymbol '(' dims+=Expression[','] ')';

// ==================================
// Loop and control statements
// ==================================
For: /\bFOR\b/ var=Variable '=' start=Expression /\bTO\b/ end=Expression (/\bSTEP\b/ step=Expression)?;
Next: /\bNEXT\b/ var=Variable;
If: /\bIF\b/ condition=Expression /\bTHEN\b/ statements+=Statement[':'];

// ==================================
// Colour control statements (CLASS_07)
// ==================================
ColourOp: /\bINK\b/ | /\bPAPER\b/ | /\bFLASH\b/ | /\bBRIGHT\b/ | /\bINVERSE\b/ | /\bOVER\b/;
ColourParam: name=ColourOp expr=Expression;
ColourStmt: ColourParam;

// ==================================
// Graphics statements (CLASS_09)
// ==================================
Plot: /\bPLOT\b/ (colours*=ColourParam[';'] ';')? expr1=Expression ',' expr2=Expression;
Draw: /\bDRAW\b/ (colours*=ColourParam[';'] ';')? expr1=Expression ',' expr2=Expression (',' expr3=Expression)?;
Circle: /\bCIRCLE\b/ (colours*=ColourParam[';'] ';')? expr1=Expression ',' expr2=Expression ',' expr3=Expression;

// ==================================
// Print and Input statements (CLASS_05)
// ==================================
PrintItem: ColourParam | At | Tab | Expression;
At: /\bAT\b/ expr1=Expression ',' expr2=Expression;
Tab: /\bTAB\b/ expr=Expression;
PrintSeparator: ',' | ';' | '\'';
PrintSeparatedItem: item=PrintItem? sep=PrintSeparator;
Print: /\bPRINT\b/ items*=PrintSeparatedItem (final=PrintItem)?;
Lprint: /\bLPRINT\b/ items*=PrintItem[','];

InputItem: ColourParam | At | Tab | Line | VarDest | Expression;
PrintSeparator: ',' | ';' | '\'';
InputSeparatedItem: item=InputItem? sep=PrintSeparator;
Input: /\bINPUT\b/ items*=InputSeparatedItem (final=InputItem)?;

Line: /\bLINE\b/ expr=Expression;

// ==================================
// Cassette/Storage statements (CLASS_0B)
// ==================================
SaveMode: Line | /\bCODE\b/ addr=Expression (',' length=Expression)? | /\bDATA\b/ var=Variable | 'SCREEN$';
Save: /\bSAVE\b/ name=Expression (mode=SaveMode)?;
Load: /\bLOAD\b/ name=Expression (mode=SaveMode)?;
Verify: /\bVERIFY\b/ name=Expression (mode=SaveMode)?;
Merge: /\bMERGE\b/ name=Expression;

// ==================================
// User-defined functions
// ==================================
DefFn: /\bDEF\b/ /\bFN\b/ name=VarSymbol ('(' params+=Variable[','] ')')? '=' expr=Expression;

// ==================================
// Rem (special case - consumes to EOL)
// ==================================
Rem: /\bREM\b/ comment=/[^\n]*/;
Label: name=/@[A-Z][A-Z0-9_]*/;
